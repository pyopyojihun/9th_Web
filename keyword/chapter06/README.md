<h1>Chapter06 keyword 정리</h1>

<h3>Tanstack Query란?</h3>

- 서버 상태를 중심으로 비동기 데이터 패칭 캐싱 동기화, 리페치 및 에러/로딩 상태 관리를 표준화해 주는 라이브러리 입니다.

<h3>Tanstack Query Devtools란? </h3>
REACT에서 Tanstack Query가 관리하는 쿼리 / 뮤테이션의 캐시,상태, 리페치,에러 등을 시각적으로 확인 할 수 있는 개발 도구에요.

<h3>useQuery</h3>
- Tanstack Query가 제공하는 데이터 조회 훅이다.
- queryKey 배열로 데이터를 식별하고 , queryFn을 실행하여 가져오며 가져온 결과를 자동 /리패치/에러,로딩 상태와 함께 관리한다.

- `gcTime`은 무엇인가요?
  캐시 데이터를 메모리에 얼마나 오래 보관할지 정하는 것이다.
  단위는 밀리초이거 데이터가 사용되지 않게 된 후 얼마나 오래 캐시에 남겨둘지를 결정한다.
- `staleTime`은 무엇인가요?
  데이터가 신선하다고 간주되는 시간으로 staleTime 동안은 컴포넌트가 리렌더링되거나 다시 마운트되어도 자동으로 refetch되지 않는다.
- 두 값을 어떤 식으로 설정하여야 `캐싱 전략에 유리`한가요?
  - staleTime은 항상 최신상태를 유지해야하므로 매우 짧게 (1~5초)
  - gcTime은 새로고침 빈도가 높으므로 오래 유지할 필요가 없으므로 1~2분 정도가 적당한 것같다.

<h3>Pagination</h3>
서버에서 클라이언트로 데이터를 전송할 때, 한번에 모든 데이터를 보내지 않고 일정한 단위로 나누어 전송하고 보여주는 기법이다.

- 오프셋 기반과, 커서 기반으로 나누어진다

- 오프셋 기반 페이지네이션
  - 숫자 매기기 방식으로 불리는데 웹사이트 하단에 있는 [1][2][3]형태의 페이지 이동 방식이다.
    - LIMIT: 한 페이지에 보여줄 데이터의 개수
    - OFFSET: 데이터를 건너뛸 시작점

```
// 3페이지를 요청하는 URL
// 'limit'은 보통 서버의 기본값으로 두기도 합니다.
const pageNumber = 3;
const pageSize = 10;
const url = `/api/posts?page=${pageNumber}&size=${pageSize}`;
```

- 주의할 점

  - 오프셋 기반은 구현이 매우 직관적이지만, 치명적인 단점이 두가지가 있다.

  1. 데이터 중복/누락 문제
     - 페이지를 이동하는 사이에 새로운 데이터가 추가되거나 기존 데이터가 삭제 /변경되면 , 데이터의 순서가 밀리거나 당겨져서 사용자가 이미 본 데이터를 다시 보거나, 일부 데이터를 건너뛰고 못 볼 수 있다.
  2. 느려지는 성능
     - OFFSET값이 커질수록 데이터베이스의 쿼리 성능이 점점 느려진다.

- 커버 기반 페이지 네이션

  - 오프셋 기반의 고질적인 단점인, 데이터 누락/중복과 깊은 페이지에서의 성능 저하 문제를 해결하기 위해 등장한 방식이다.
  - 실시간으로 데이터가 끊임없이 추가되는 무한 스크롤 구현에 가장 적합한 방식이다.

  - 원리 : 마지막으로 조회한 데이터의 위치를 다음 페이지를 시작할 기준점으로 활용한다.
  - 커서 : 보통 데이터의 고유하고 순서가 있는 값을 사용
  - 요청 방식 : 클라이언트는 서버에 "이전페이지의 마지막항목 커서 값을 기준으로 그 다음 데이터를 몇개를 줘" 라고 요청.

```
// 이전에 받아온 목록의 마지막 게시물 ID가 95라고 가정합니다.
const lastCursorId = 95;
const pageSize = 10;
// 'after'라는 쿼리 파라미터에 커서 값을 담아 전달합니다.
const url = `/api/posts?after=${lastCursorId}&size=${pageSize}`;
```

- 장점
  1. 데이터 중복/누락 문제 해결
     - 데이터를 가져오는 기준이 건너뛴 개수가 아니라 특정 항목의 값이기 떄문에 페이지를 불러오는 사이에 새로운 데이터가 추가되더라도 사용자가 보던 흐름에는 영향을 주지 않는다.
  2. 우수한 성능
     - 깊은 페이지로 이동할 때 이전 데이터를 모두 건너뛸 필요가 없어서 쿼리 속도 젛 없이 일관되게 빠른 성능을 유지할 수 있음.
- 주의할 점
  1. 랜덤 접근 불가
     - 특정 페이지를 클릭해 바로 이동하는 랜덤 접근이 불가능. 다음페이지를 요청하려면 반드시 이전 페이지의 마지막 커서 값이 필요하기 떄문이다. 무한 스크롤레 주로 사용된다.
  2. 복잡한 쿼리 조건
     - 정렬조건이 여러개일 경우 WHERE절의 조건이 복잡하고 까다로워질 수 있다.

<h3>왜 useInfiniteQuery일까</h3>

- 문제 : 한번에 모든 데이터를 받아 렌더링하면 초기 로딩이 느리고, 스크롤 UX도 좋지않은 단점이 있다.

- 따라서 데이터를 페이지 단위로 분할해 적시에 불러오고 이미 받은 페이지는 캐시에 누적해 다시 쓰는 일이다.

- useInfiniteQuery가 해주는 일
  - 현재 어디까지 가져왔는지 기억하고,
  - 다음에 무엇을 가져올지를 함수로 정의하게 해준다.
  - 그리고 fetchNextPage/hasNextPage/isFEtchingNExtPAge와 같은 무한 스크롤 전용 상태/함수를 제공한다.

<h3>동작흐름</h3>

- **initialPageParam**: 첫 페이지 요청 값이에요(예: 1).
- **getNextPageParam**: 서버 응답을 바탕으로 **다음 페이지 파라미터**를 계산해요. 없으면 `undefined`를 반환해 종료해요.
- **data.pages**: 받아온 페이지들이 순서대로 누적돼요.
- **fetchNextPage / hasNextPage**: “다음 불러오기”/“더 있음 여부”를 제어해요.

<h3>Skeleton UI란 무엇인가요?</h3>

- 뼈대만 있는 사용자 인터페이스를 의미한다. 웹사이트나 앱이 데이터를 불러오는 동안 사용자에게 텅 빈 하나얀 화면 대신 실제 콘텐츠가 들어갈 자리와 윤곽을 미리 보여주는 디자인 기법이다.

- 왜 뼈대만 보여주는가?
    - 웹페이지에 데이터가 느리게 로딩되어 아무것도 뜨지 않고 하얀 화면만 보고 있다면 이게 잘 작동하는지, 언제쯤 뜨는건지, 하고 불안감 또는 지루함을 느끼고 페이지를 닫아버릴 확률이 올라간다.
    - 이때 Skeleton UI가 데이터가 지금 로딩중이고 곧 보여줄거야 라는 긍정적인 신호를 시각적으로 전달하여 사용자 경험을 개선하는 핵심적인 방법이다

    - 장점 
        1. 체감 로딩 시간 감소
        2. 사용자 이탈률 감소
        3. 시각적 일관성 유지
        4. 피드백 제공
    - 단점
        1. 제작 및 관리 비용이 더 많이 들어간다.
        2. 로딩이 짧을 때 역효과
        3. 실제 UI와의 유사성이 너무 다르면 혼란을 느낄 수 있다.