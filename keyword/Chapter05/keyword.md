# CORS란?

**CORS**는 **교차 출처 리소스 공유(Cross-Origin Resource Sharing)**의 약자이다. 이름 그대로, **다른 출처(Origin)**에 있는 자원(리소스, 즉 API 데이터)을 공유할 수 있도록 허용하는 메커니즘이다.

## SOP (Same-Origin Policy)

- **SOP의 원칙:** 웹 브라우저는 기본적으로 **같은 출처**에서 온 리소스만 접근하도록 허용한다.
  - **출처(Origin) 구성 요소:** **프로토콜 (Protocol) + 도메인 (Domain) + 포트 (Port)**
- **예시:**
  - `http://app.com:8080`과 `http://app.com:8080`은 **동일 출처**이다.
  - `https://app.com:8080`은 프로토콜이 다르므로 **다른 출처**이다. (SOP 위반)
  - `http://api.com:8080`은 도메인이 다르므로 **다른 출처**이다. (SOP 위반)

SOP는 악의적인 웹사이트가 사용자 모르게 다른 사이트의 민감한 데이터(예: 은행 잔액, 개인 정보)를 훔쳐 가는 것을 막기 위한 방패이다.

하지만 현대 웹 개발에서는 프론트엔드(예: `localhost:3000`)와 백엔드 API 서버(예: `api.myservice.com:8080`)가 **다른 출처**를 가질 수밖에 없다. SOP의 엄격함을 유지하면서도 필요한 통신을 허용하기 위해 태어난 것이 바로 **CORS**이다.

---

# 서버에서 HTML 문서를 응답할 때 CSP를 적용하려면 어떤 HTTP 응답 헤더를 설정해야 하나요?

서버에서 HTML 문서를 응답할 때 Content-Security-Policy HTTP 응답 헤더를 설정하여 CSP 정책을 적용할 수 있다.  
`Content-Security-Policy` 헤더는 다른 자원(스크립트, 스타일, 이미지 등)에 대한 접근을 제어하며, `default-src 'self'`와 같이 설정하면 현재 문서와 동일한 출처의 리소스만 허용된다.

```tsx
res.setHeader("Content-Security-Policy", "default-src 'self';");
```

- `res.setHeader(...)`: Node.js 또는 Express.js에서 HTTP 응답 헤더를 설정하는 함수.
- `'Content-Security-Policy'`: 설정할 헤더의 이름.
- `"default-src 'self'"`: 설정할 정책 내용.
  - `default-src`: 다른 자원(스크립트, 스타일, 이미지 등)에 대한 정책이 별도로 명시되지 않았을 때 사용할 기본 'fallback' 정책입니다.
  - `'self'`: 현재 문서와 '동일한 출처(origin)'의 리소스만 허용한다는 의미입니다.

`default-src`는 다른 세부적인 규칙이 명시되지 않은 모든 종류의 리소스에 대해 적용할 기본 규칙이다.  
비유하면, 건물의 기본 출입 정책과 같다.

- 기본 정책(`default-src`)은 이 건물은 기본적으로 우리 회사 직원(`self`)만 출입할 수 있다.
- 개별 정책(`img-src`, `script-src` 등)은 특정 층이나 구역에서 예외적으로 외부 사람도 출입할 수 있다.
- 별도의 규칙이 없는 구역은 기본 정책(fallback 정책)을 따른다.

# `default-src 'self'` 설정은 브라우저에게 어떤 보안 정책을 의미하며 `'self'` 값은 어떤 출처를 포함하거나 제외하나요?

`default-src 'self'` 설정은 브라우저에게 "이 웹페이지를 구성하는 모든 리소스는 현재 페이지와 동일한 출처에서만 가져와야 한다"라고 지시하는 강력한 보안 정책이다.  
명시적으로 허용되지 않은 외부 출처의 모든 리소스는 차단된다.

- `default-src`는 fallback 정책으로, 다른 구체적인 리소스 지시자가 없으면 기본값으로 적용된다.
- `'self'`는 현재 문서와 동일한 출처만 허용하며, 외부 CDN, 다른 도메인, 서브도메인은 차단한다.

동일 출처(Same Origin)는 다음 세 가지가 모두 일치해야 한다.

1. 프로토콜: https
2. 호스트: 예) matthew.com
3. 포트: 예) 443

# 악성 스크립트를 주입했을 때 CSP는 어떻게 동작하나요?

### 네트워크 탭 - 요청 차단

- 아무 일도 일어나지 않는다.
- 외부 도메인(`hacker.com`)으로 향하는 네트워크 요청이 발생하지 않는다.
- CSP가 악성 스크립트 실행을 원천적으로 차단하기 때문이다.

### 브라우저 콘솔 - 위반 경고

- CSP 위반 경고 메시지가 표시된다.
- 인라인 스크립트가 차단되며, 실행되지 않는다.

# 기본 CSP 설정에서 인라인 스타일이 차단되는 이유는 무엇인가요?

`width:600px` 인라인 스타일이 적용되지 않은 이유는 `default-src 'self'` 정책 때문이다.

1. Fallback 정책 적용: `style-src` 규칙이 없으면 fallback 정책(`default-src 'self'`)이 적용된다.
2. 인라인 콘텐츠 차단: `'self'`는 서버에서 로드되는 파일만 허용하고, 인라인 스타일은 허용하지 않는다.
3. 보안 강화: 인라인 스크립트와 인라인 스타일 모두 악성 조작 가능성을 차단한다.

결과적으로, 인라인 스타일은 CSP 정책에 의해 차단된다.

# 구글 애널리틱스, 카카오맵 등 외부 API가 CSP 때문에 차단되는 이유를 건물 비유로 설명해주세요.

- 웹사이트 → 우리 회사 건물
- CSP(`default-src 'self'`) → 직원만 출입 가능 엄격 보안 정책
- 외부 API(구글 애널리틱스, 카카오맵) → 방문증 없는 외부 협력사

### 차단되는 이유 - "방문증 없는 외부 협력사"

이때 구글 애널리틱스나 카카오맵 같은 외부 API는 '우리 회사 정직원'이 아닙니다.

이들은 분명히 우리가 초대한, 꼭 필요한 협력사들입니다. 하지만 이들은 우리 회사 ID 카드`'self'`가 아닌, 각자의 회사 ID 카드를 가지고 있습니다.

보안 규칙(`CSP`)이 너무 엄격해서 "무조건 우리 회사 정직원 ID 카드(`'self'`)만"이라고 설정되어 있으면, 입구의 보안 요원(브라우저)은 이 협력사들을 보고 저희 정직원 ID가 없으므로 이 건물에 출입할 수 없다고 출입을 막습니다.

결국, 구글 애널리틱스는 건물에 들어오지 못해 방문객 통계를 낼 수 없고, 카카오맵도 로비에 지도를 설치하지 못해 서비스가 멈춥니다.

보안을 너무 엄격하게만 적용하다 보니, 우리가 정상적인 운영을 위해 초대했던 필수 인력(외부 API)들조차 출입을 거부당해 서비스가 마비되는 것입니다.

# Report-Only 모드에서 브라우저와 서버는 어떤 동작을 수행하나요?

### 브라우저의 동작

- 정책 위반 리소스를 감지하지만 차단하지 않는다.
- 리소스를 정상적으로 로드하고 실행한다.
- 위반 내용을 JSON 형식으로 서버에 전송한다.

### 서버의 동작

- 브라우저가 전송한 리포트를 수신한다.
- 리포트를 분석하여 어떤 페이지, 어떤 정책, 어떤 리소스가 위반했는지 기록한다.
- 실행 차단은 발생하지 않고 진단 및 기록 목적만 수행한다.

# CSP만으로 CSRF를 막을 수 없을 때 사용할 수 있는 다른 보안 조치 2가지는 무엇인가요?

## 1. SameSite 쿠키 속성

- 쿠키 속성으로 CSRF 공격을 방어한다.
- 다른 도메인에서 시작된 요청에는 브라우저가 쿠키를 전송하지 않는다.
- 공격자가 요청을 위조해도 서버는 로그인되지 않은 요청으로 처리하여 공격을 차단한다.

## 2. X-Frame-Options 헤더

- 클릭재킹 공격을 방어한다.
- `DENY` 또는 `SAMEORIGIN`으로 설정하면 다른 도메인이 페이지를 `<iframe>` 안에 삽입하지 못한다.
- 공격자가 iframe을 이용한 클릭 가로채기 공격을 시도해도 원천적으로 차단된다.

---

# 출처(Origin)는 어떤 세 요소의 조합으로 결정되나요?

브라우저가 같은 출처인지 판단할 때 기준이 되는 세 가지 핵심 요소는 다음과 같다.

1. **프로토콜 (Protocol)**
   - 웹사이트에 접속하는 방식이다. (예: `http://` 또는 `https://`)
2. **호스트 (Host)**
   - 웹사이트의 주소, 즉 도메인 이름이다. (예: `example.com`, `blog.example.com`)
3. **포트 (Port)**
   - 서버에 접속하는 통로 번호이다. (예: `80`, `443`, `8080`)

# 출처의 요소가 다른 경우 같은 출처인지 아닌지 예시 3개

SOP 기준 URL을 `https://example.com` (기본 포트 443)이라고 가정한다.

### 같은 출처 (허용)

- **URL:** `https://example.com/page.html`
- **이유:** 프로토콜(`https`), 호스트(`example.com`), 포트(`443`)가 모두 일치한다.

### 다른 출처 (차단)

- **예시 1 (프로토콜 불일치):** `http://example.com`
  - 이유: 프로토콜이 기준(`https://`)과 다르므로 차단된다.
- **예시 2 (포트 불일치):** `https://example.com:8080`
  - 이유: 포트가 8080으로 기준 443과 다르므로 차단된다.

# `fetch` 기반 악성 스크립트를 다른 출처로 실행했을 때 브라우저 동작

### 1. 네트워크 전송 여부

- 요청은 전송된다.
- SOP는 요청 자체를 막지 않으므로 `hacker.com`으로 쿠키 포함 네트워크 요청이 실제로 발생한다.

### 2. 응답 사용 가능성

- 브라우저는 응답 데이터를 읽거나 사용하는 것을 차단한다.
- 요청은 서버로 전달되지만, 다른 출처의 응답을 스크립트가 접근할 수 없다.

### 3. 브라우저 콘솔 메시지

- “동일 출처 정책으로 인해 원격 리소스를 차단했다”와 같은 교차 출처 요청 차단 오류가 표시된다.

# SOP가 세션 하이재킹 시도를 방지하는 방식

SOP는 스크립트가 다른 출처 데이터를 읽지 못하게 막아 세션 하이재킹 시도를 방지한다.

### 1. 허용되는 것: 네트워크 요청 전송

- 악성 사이트가 정상 사이트 API로 `fetch` 요청을 보내면, 요청은 브라우저에 의해 전송된다.
- 사용자가 로그인 상태라면 세션 쿠키가 포함되어 서버가 정상 요청으로 인식한다.

### 2. 차단되는 것: 응답 데이터 접근

- 브라우저가 응답을 받지만, 스크립트는 데이터를 읽거나 접근할 수 없다.
- 결과적으로 민감한 데이터 탈취가 차단된다.

### 3. 브라우저 반응

- 콘솔에 "동일 출처 정책으로 원격 리소스를 차단" 메시지가 표시된다.
- 요청은 보내지만 응답 데이터 접근을 차단하여 세션 정보 보호가 가능하다.

# SOP가 반드시 동일 출처에서만 접근하도록 하는 브라우저 API/리소스 3가지

### 1. `fetch()` API

- 다른 서버로 데이터를 요청하고 응답받는 최신 표준 API이다.
- **제한 이유:** 다른 출처의 응답 데이터를 읽으면 사용자의 민감 정보를 탈취할 수 있으므로 SOP가 차단한다.

### 2. `XMLHttpRequest` (XHR)

- 비동기 데이터 전송을 위해 과거부터 사용된 API이다.
- **제한 이유:** 응답 데이터를 스크립트가 읽는 것을 방지하기 위해 SOP가 적용된다.

### 3. `@font-face` 웹 폰트

- CSS를 통해 커스텀 폰트를 서버에서 불러와 적용한다.
- **제한 이유:** 폰트 파일도 리소스로 간주되며, 다른 출처의 리소스 접근을 제한한다.

# SOP와 CSP의 차이점 (요점 4개)

### 1. 적용 주체

- **SOP:** 브라우저 고유 기능으로, 별도 서버 설정 없이 자동 적용된다.
- **CSP:** 서버가 정책을 설정하고 브라우저가 이를 수행하는 협력 모델이다.

### 2. 설정 방식

- **SOP:** 개발자가 설정할 필요 없이 자동 적용된다.
- **CSP:** 개발자가 HTTP 헤더로 명시적으로 정책을 설정해야 한다.

### 3. 제어 가능성

- **SOP:** 개발자가 끄거나 수정할 수 없다. CORS를 통해 우회만 가능하다.
- **CSP:** 개발자가 정책을 세밀하게 제어할 수 있고, `Report-Only` 모드도 지원한다.

### 4. 핵심 비유

- **SOP:** 건물 자체의 구조적 보안 장치, 외부인이 내부 데이터를 훔치지 못하도록 막는다.
- **CSP:** 건물주가 정하는 보안 규칙, 허용된 출처만 출입 가능하게 하거나 인라인 스크립트 등 규칙을 설정한다.

# SOP 관련 차단 오류 원인 확인 체크리스트 및 대응 방안

### 체크리스트

1. **호스트(Host)가 다른가?**
   - 서브도메인이 다르면 다른 출처로 간주된다.
2. **프로토콜(Protocol)이 다른가?**
   - HTTPS 페이지에서 HTTP API를 호출하면 차단된다.
3. **포트(Port)가 다른가?**
   - 로컬 개발 시 프론트엔드와 백엔드 포트가 다르면 다른 출처로 간주된다.

### 임시 대응 방안 (로컬 개발용)

- 브라우저 확장 프로그램(예: Allow-CORS)을 설치하여 테스트한다.

### 영구 대응 방안 (배포/운영용)

- API 서버에서 **CORS 정책**을 설정한다.
- `Access-Control-Allow-Origin` 헤더에 허용할 출처를 명시하여 브라우저가 안전하게 요청을 수행하도록 한다.

---

# 브라우저가 응답 본문을 사용하지 못하는 이유는 무엇인가요?

#### 1. 네트워크 요청 및 응답 처리 과정

1. 브라우저(`http://localhost:8080`)에서 `fetch('http://localhost:8081/resource.json')` 스크립트가 실행된다.
2. 브라우저는 요청을 보내는 자신의 출처(`http://localhost:8080`)와 요청을 받는 서버의 출처(`http://localhost:8081`)가 다름을 인지한다.
3. 브라우저는 이 요청이 교차 출처 요청(Cross-Origin Request)이라고 판단하고, `GET` 메소드는 단순 요청(Simple Request)이므로 즉시 `http://localhost:8081/resource.json`으로 요청을 보낸다. 이때 요청 헤더에 자신의 출처를 알리는 `Origin: http://localhost:8080` 헤더를 자동으로 포함시킨다.
4. 서버(`8081`)는 요청을 받고, `resource.json` 파일을 찾아 `200 OK` 상태 코드와 응답 본문(JSON 데이터)을 브라우저로 다시 보낸다.

요청 전송과 응답 수신 자체는 성공적으로 완료된다.

#### 2. 브라우저가 응답 본문을 사용하지 못하는 이유

브라우저의 동일 출처 정책(Same-Origin Policy) 때문에 스크립트가 응답 데이터에 접근하지 못한다.

1. 브라우저는 서버로부터 받은 응답 헤더를 검사한다.
2. 브라우저는 교차 출처 요청을 허용하는지 판단하기 위해 `Access-Control-Allow-Origin` 헤더를 찾는다.
3. `8081` 서버 응답에 해당 헤더가 없으므로, 브라우저는 응답 본문에 접근하는 것을 차단하고 콘솔에 "교차 출처 요청 차단" 오류를 표시한다.

즉, 서버가 응답 헤더에 `Access-Control-Allow-Origin: http://localhost:8080` 또는 `*`를 포함하지 않았기 때문에 브라우저가 응답 사용을 막는 것이다.

# 서버가 다른 출처에서 자원을 사용할 수 있게 하려면 어떤 응답 헤더를 어떻게 설정해야 하나요?

`8081` 서버가 `http://localhost:8080` 출처에게 자원 접근을 허용하기 위해 설정해야 하는 응답 헤더는 다음과 같다.

- 헤더 이름: `Access-Control-Allow-Origin`
- 헤더 값: `http://localhost:8080`

이 헤더는 서버가 브라우저에게 "이 출처에서 온 요청은 신뢰할 수 있으니 응답 데이터를 사용해도 된다"라고 허락하는 역할을 한다. 브라우저는 자신의 `Origin` 값과 서버가 보내준 `Access-Control-Allow-Origin` 값을 비교하고 일치하면 응답 본문에 접근을 허용한다.

헤더 값을 `*`로 설정하면 모든 출처 요청을 허용하지만, 특정 출처를 명시하는 것이 보안상 더 안전하다.

# 단순 요청으로 분류되기 위해서는 어떤 두 가지 조건과 `GET /resource.json` 요청이 단순 요청에 해당하는 이유

교차 출처 요청이 단순 요청(Simple Request)으로 분류되기 위해서는 다음 두 가지 조건을 모두 만족해야 한다.

1. 허용된 HTTP 메소드 사용: `GET`, `POST`, `HEAD` 중 하나여야 한다.
2. 안전한 헤더 사용: 브라우저가 자유롭게 사용할 수 있는 안전한 헤더 목록(예: `Accept`, `Accept-Language`, `Content-Language`, `Content-Type`, `Range`)에 포함된 헤더만 사용해야 한다.

`GET /resource.json` 요청이 단순 요청에 해당하는 이유는 위 두 조건을 모두 만족하기 때문이다. 즉, `GET` 메소드를 사용했고, 별다른 커스텀 헤더를 추가하지 않고 안전한 헤더만 사용했기 때문이다.

# 브라우저에서 `X-Goguma`라는 커스텀 헤더를 추가했을 때 왜 차단이 발생하나요?

`X-Goguma` 헤더는 브라우저가 정한 안전한 헤더 목록에 포함되어 있지 않으므로 차단이 발생한다. 브라우저는 이 커스텀 헤더를 서버가 허용하는지 확인해야 하고, 서버가 허락하지 않았기 때문에 요청이 차단된다.

해결 방법은 서버가 이 커스텀 헤더를 허용한다고 명시하는 것이다.

- 헤더 이름: `Access-Control-Allow-Headers`
- 헤더 값: `X-Goguma`

이렇게 설정하면 브라우저가 커스텀 헤더를 포함한 요청을 허용하고, 응답 본문에 접근할 수 있다.

# `PUT` 요청을 보낼 때 브라우저는 왜 먼저 `OPTIONS` 요청을 보내나요?

`PUT` 메소드는 `GET`, `POST`, `HEAD`와 달리 단순 요청에 해당하지 않기 때문에 브라우저는 먼저 사전 요청(Preflight Request)을 `OPTIONS` 메소드로 서버에 보낸다. 이는 "내가 `PUT` 요청을 보내도 안전한가?"를 확인하는 절차이다.

- 브라우저가 보내는 사전 요청 헤더: `Access-Control-Request-Method: PUT`
- 서버가 응답해야 하는 헤더: `Access-Control-Allow-Methods: PUT`

사전 요청이 성공하면 실제 `PUT` 요청이 이어진다.  
즉, 브라우저가 `OPTIONS` 요청으로 허용 여부를 확인하고, 서버가 허용 응답을 보내면 실제 `PUT` 요청을 보내고 서버가 처리한 후 응답을 받는 흐름이다.

---

# RBAC vs ABAC 접근 제어

## RBAC (Role-Based Access Control) : 역할 기반 접근 제어

RBAC은 사용자의 역할(Role)을 기준으로 권한을 할당하는 방식이다. 사용자가 어떤 역할을 가지느냐에 따라 자동으로 해당 역할에 속한 권한을 가지게 된다. 예를 들어, '재무팀 관리자' 역할에는 '결제 승인' 권한이 있고, 김철수 사원이 이 역할을 부여받으면 결제 승인 권한을 갖는다.

### 특징

- 관리 효율성이 높다. 사용자마다 권한을 직접 부여할 필요 없이 역할만 할당하면 된다.
- 구조가 단순하고 명확하다. 대부분 조직 환경에서 적용하기 쉽다.
- 정적(Static) 모델이다. 역할이 한 번 정의되면 쉽게 변경되지 않는다.

## ABAC (Attribute-Based Access Control) : 속성 기반 접근 제어

ABAC은 속성(Attribute)과 조건을 기반으로 권한을 동적으로 결정하는 방식이다. 사용자의 속성, 리소스 속성, 작업 속성, 환경 속성을 모두 고려하여 접근을 허용할지 거부할지를 판단한다. 예를 들어, '재무팀 김철수 사원이 평일 업무 시간에만 극비 파일을 읽을 수 있다'와 같이 매우 세밀한 제어가 가능하다.

### 특징

- 세분화된 제어가 가능하다. 시간, 위치, 장치 등 상황에 따라 접근 권한을 세밀하게 조정할 수 있다.
- 동적(Dynamic) 모델이다. 접근 요청 시 실시간으로 정책을 평가하여 권한을 결정한다.
- 유연성이 높다. 새로운 사용자나 리소스가 추가되어도 속성 기반 정책을 통해 쉽게 적용할 수 있다.

# RBAC의 한계

RBAC는 사용자가 처한 상황이나 대상에 따라 권한을 유연하게 조정하기 어렵다.  
예를 들어, 한 사용자가 여러 학원에 소속되어 학원마다 다른 역할을 가져야 할 때, 기존 RBAC 방식으로는 이를 깔끔하게 처리하기 힘들다.  
또한 학생이 자신이 작성한 챌린지만 삭제할 수 있는 조건과 같이 사용자와 리소스 간 속성을 고려해야 하는 경우, RBAC로는 한계를 드러낸다.

권한 요구사항이 복잡해지면 권한 확인 로직이 코드 전체에 흩어져 유지보수가 어렵다. RBAC는 단순한 "A 역할은 C가 가능하다"라는 정책에는 효과적이지만, 역할 외 속성이나 문맥을 고려해야 하는 동적인 예외 케이스를 처리하기 어렵다.

# ABAC으로의 전환, 어떤 '기준'이 적절할까요?

### 1. 역할(Role)만으로 권한 예외 처리가 불가능할 때

RBAC는 역할과 권한이 1:1로 묶여 있어, 같은 역할이라도 일부만 권한을 가져야 하는 경우에는 적용하기 어렵다.  
사용자마다 권한 차이가 발생하거나 속성 기반 조건이 개입해야 할 때 ABAC 전환이 필요하다.

### 2. 권한 판단에 문맥(Context)이 중요해질 때

사용자의 역할뿐 아니라 사용자와 리소스 간 관계, 접근 환경 등 문맥 정보를 고려해야 할 때 ABAC을 도입해야 한다.  
예를 들어, 학생은 자신이 작성한 챌린지만 삭제할 수 있고, 원장은 자기 학원의 챌린지만 삭제할 수 있는 경우이다.

### 3. 권한 확인 로직이 코드 여기저기에 흩어질 때

UI 컴포넌트나 비즈니스 로직에 권한 확인을 위한 복잡한 조건문이 분산되어 있을 때, 유지보수가 어렵고 실수가 발생하기 쉽다.  
ABAC으로 전환하면 복잡한 로직을 중앙에서 관리 가능한 함수와 정책 테이블로 추상화할 수 있다.

# 어떤 서비스 영역에 RBAC을 남겨두고, ABAC을 도입하시겠어요?

### RBAC을 남겨둘 영역

RBAC은 역할만으로 권한이 명확하게 결정되는 단순하고 정적인 영역에 남겨두는 것이 좋다.  
예를 들어, 앱 전역 권한 관리에서는 ADMIN과 USER처럼 서비스 전체에 대한 권한 구분에 적합하다.  
정책 변경 가능성이 낮고 단순한 판단이면 RBAC으로 충분하다.

### ABAC를 도입할 영역

ABAC은 권한 판단을 위해 여러 조건을 확인해야 하는 복잡하고 동적인 영역에 도입해야 한다.  
예를 들어 챌린지 관리 기능에서 삭제 권한을 결정할 때, 사용자의 역할, 챌린지 소유자 여부, 학원 소속, 개별 삭제 권한 등 다양한 속성을 확인해야 한다.  
이처럼 사용자와 리소스 관계나 세부 속성을 고려해야 하는 영역에 ABAC을 적용한다.

# 여러분들은 다른 부서에서 요청을 받았을 때 어떤식으로 해결할 것인가요?

저는 반복되는 요청과 복잡한 `if`문을 겪은 후, 문제를 근본적으로 해결하는 방식으로 행동할 것 같습니다.  
먼저 패턴을 인식하여 "역할만으로는 안 되는구나", "예외 케이스가 계속 생기는구나"라는 사실을 파악하고,  
문제가 하드코딩된 역할과 흩어진 권한 로직임을 분석해, 권한 관리 시스템을 ABAC 기반으로 리팩토링할 것을 제안합니다.  
권한 정책을 중앙 테이블에서 관리하고, 권한 확인 로직을 통일된 함수로 추상화하며, 테스트 코드를 통해 안정성을 검증합니다.  
이렇게 하면 새로운 복잡한 예외 요청이 들어와도 유연하게 대응할 수 있습니다.
