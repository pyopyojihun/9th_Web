<h1>useMutation이란 무엇인가?</h1>

- 예를들어 기존의 할일이 10갸의 데이터가 존재한다고 가정.
    1. 할일 추가 요청 성공 ! 
    2. 서버에는 11개의 할일이 된다.
    3. 하지만 화면은 여전히 10개의 목록만 보여준다.
    4. 사용자는 새로 추가된 할 일을 볼 수 없음....

    - 이때 개발자는 Mutaion(추가작업)이 성공할 때마다 Query를 수동으로 다시실행했어야 했고 매번 작업했어야함.

- useMutaiton은 서버에 데이터를 변경 (POST/PUT/DELETE)하는 작업을 수행하고, 그 결과를 체계적으로 관리한다.

    1. mutaionFn - 실제로 서버에 변경 요청을 보내는 비동기함수
    2. isPending - 요청이 진행중인지
    3. isError - 요청이 실패했는지
    4. onSuccess - 요청이 성공한 직후 실행되는 함수
    5. .mutate() - 변경 작업을 실행하는 함수

<h3>useMutation의 핵심 옵션</h3>

1. 필수 옵션 : 변경 작업을 정의한다.
    - mutationFn - 실제로 서버에 데이터를 보내는 함수를 지정한다.
2. 라이프사이클 옵션 : 변경의 전/중/후를 제어.
    - OnMutate : 요청이 서버로 보내지기 직전 호출
    - onSuccess: 요청이 성공적으로 완료되었을 떄 호출
    - onError : 요청 도중 에러가 발생했을 때 호출
    - onSettled : 성공/실패와 관계 없이 모든 작업이 끝났을 때 호출된다.

3. 설정옵션 : 안정성과 제어 강화
    - retry : Mutation이 실패했을 시, 몇번까지 자동으로 다시 시도할지 정한다.
    - retryDelay : 재시도 사이에 얼마나 기다릴지 시간을 정한다.
    - throwOnError : 에러가 났을 때 TanStack Query 내부에서 에러를 잡지않고 밖으로 던질지 정한다.
    - meta : 이 Mutation에 대한 추가 정보를 넣을 수 있다.


<h1>낙관적 업데이트 - OptimisticUpdate</h1>

```OptimisticUpdate란 무엇인가?```
- 사용자가 버튼을 클릭해서 데이터를 변경할때 우리는 보통 서버에 요청을 보내고 그 결과를 기다린다. 하지만 이 과정에서 네트워크의 지연 떄문에 0.5초에서 1초정도의 기다림이 생긴다. 여기서 낙관적 업데이트는 어차피 요청은 성공할거야! 라고 미리 가정하고, 서버 응답이 오기 전에 클라이언트를 먼저 바꿔버리는 것이다.

<h3>주요개념</h3>

1. 즉각적인 UI 업데이트 - 사용자가 '추가'버튼을 누르는 동시에 화면에 새로운 항목이 나타난다 서버 요청의 성공여부는 나중에 확인한다.
2. 가정 - 이 요청은 99%성공할 것이다라고 믿고 UI를 변경한다.

3. 에러 처리 및 롤백 - 만약 서버 요청이 실패하면 방금 미리 보여줬던 변경사항을 취소하고 에러가 났다고 사용자에게 알려준다.

- 장점 
    - 즉각적인 반응 : 앱이 매우 빠르다고 느낄 수 있음
    - 네트워크 지연 무시 : 네트워크가 약간 느리더라도 지연을 체감하지 못한다.

- 단점 
    - 복잡한 롤백 로직 : 서버요청이 실패했을 때 원래상태가 무엇이었는지 기억해야하고 그 상태로 되돌리는 롤백을 추가해야한다.
    - 일시적인 불일치 : 잠시동안 클라이언트 화면과 서버의 실제 데이터가 다를 수 있다.

- **낙관적 업데이트(OptimisticUpdate)**를 왜 도입해야 하는지, 이 패턴이 해결하려는 문제를 실제 서비스 맥락에서 설명해보세요.
    
    서버 왕복을 기다리는 동안 화면이 늦게 바뀌어 생기는 “답답함”을 없애 , 사용자가 즉시 변화를 보게하려는 패턴이 낙관적 업데이트이다. 실서비스에서 좋아요, 댓글, 작성 같은 잦은 액션마다 응답→ 무효화 → 재요청을 기다리면 UX가 둔해지는데, 이 패턴은 캐시를 먼저 바꾸고 실패하면 롤백, 마지막에 재검증으로 정합성을 맞춰 즉시반응 및 최종 정확성을 동시에 잡는다.

- TanStack Query 기반 구현 흐름을 `onMutate → (mutate) → onError → onSettled` 순서로 기술해주세요..
    1. OnMutate 
        1. 관련 쿼리 취소 : await queryClient.cancelQueries
        2. 이전 상태 스냅샷 저장 : const prev = queryClient.getQueryData(queryKey)
        3. 캐시 즉시 수정 : queryClient.setQueryData(queryKey , draft ⇒ …)
        4. 필요 시 리스트/카운트 동기 수정
        5. 반환값으로 ctx 리턴
    2. mutate (실제 네트워크 호출)
        1. 서버에 요청 전송
        2. 실패/성공 여부는 아래 훅들에서 처리한다.
    3. onError(롤백, 알림)
        1. ctx?.prev가 있으면 setQueryData로 원복
        2. 사용자 알림, 로그 남기기 
    4. onSettled (최종 동기화)
        1. 성공/실패 무관 재검증 : queryClient.invalidateQuaries(queryKey)
        2. 여러 캐시가 연관될 경우 관련 키들을 함께 무효화
        3. 잠금/로딩 플래그 해제 등 마무리

- ToDo “생성” 및 “좋아요 토글”에 **낙관적 업데이트(OptimisticUpdate)**를 적용했을 때의 **실패/충돌 롤백 전략**을 설계해주세요.
    1. onMutate 
        1.  await qc.cancelQueires([’todo’,id]) 등을 이용해 아이템을 포함하는 목록 쿼리도 취소한다.
        2. 이전 스냅샷 저장 : prevItem, prevLists[]
        3. context로 prevItem, prevLists 등을 반환
    2. mutate 
        1. 서버에 현재 목표 상태와 클라이언트 측 버전 을 전달.
        2. 서버가 조건부 갱신을 지원하면 불일치시 409/412로 명확히 실패하게한다
    3. onError 
        1. 권한/검증 실패 : 스냅샷으로 원상복귀 + 안내
        2. 충돌이면 즉시 원복후 강제로 재검증을 한다.
    4. onSettled
        1. 이 아이템이 들어있는 모든 목록 키도 함께 무효화