<h1>리프레시 토큰 기반의 안전한 접근 제어 전략과 소셜 로그인</h1>

```OAuth란?```
- 권한 부여를 위한 표준 프레임워크이다. "로그인"이라고 부르는 인증과는 본질적으로 다름

```OAuth의 주요 역할자.```
1. 리소스 소유자 : 데이터의 주인, 사용자
2. 클라이언트 : 리소스 소유자 대신 데이터를 요청하려는 우리의 앱
3. 권한 서버 : 사용자 신원을 확인하고, 클라이언트에게 접근 토큰을 발급하는 서버.
4. 리소스 서버: 보호된 사용자 데이터를 실제로 가지고 있는 서버. 접근 토큰을 검증하여 유효하면 데이터를 제공한다.

```OAuth2.0 인증 및 권한 부여 프로세스```
1. 사용자 인증 및 권한 부여 요청
    - 클라이언트 애플리케이션이 리소스 소유자에게 특정 리소스에 접근할 수 있도록 허용하지를 요청

2. 인가 코드 발급
    - 인가 서버는 리소스 소유자가 동의하면 클라이언트에게 인가 코드를 발급한다. 이 코드는 일회용이며, 액세스 토큰 요청 시에 사용된다.

3. 액세스 토큰 발급 :
    - 클라리언트는 받은 인가 코드를 인가 서버에 제출, 유효하다면 액세스 토큰을 발급 받는다. 이 토큰은 리소스 서버에 보호된 데이터를 요청할 때 사용된다.

4. 리소스 접근 
    - 클라이언트는 액세스 토큰을 사용하여 리소스 서버에서 보호된 데이터를 요청한다.


```OAuth의 권한부여 흐름```

1. PKCE준비 : REACT 앱이 code_verifier를 생성하고, 이를 해시한 code_challenge를 만들어서 준비한다.

2. 권한 요청 : REACT 앱이 사용자 브라우저를 권한 서버로 리다이렉트한다.

3. 코드발급 : 권한 서버에서 로그인 및 동의가 완료되면, 사용자 브라우저를 우리 앱의 redirect_url로 다시 리다이렉트하며 Authorization Code를 전달한다

4. 토큰 교환

5. 리소스 접근

```CORS란 무엇인가?```
- CORS는 교차 출처 리소스 공유의 약자이다. 이름 그대로 다른 출처에 있는 자원을 공유할 수 있도록 허용하는 매커니즘이다.

- 원칙 : 웹 브라우저는 기본적으로 같은 출처에서 온 리소스만 접근하도록 허용한다
    - 출처 구성요소 : 프로토콜 + 도메인 + 포트

- 악의 적인 사이트가 사용자 모르게 다른 사이트의 민감한 데이터를 훔쳐 가는 것을 막기 위한 방패이다.
- 하지만 현대 웹 개발에서는 프론트엔드와 백엔드 API서버가 다른 출처를 가질 수 밖에 없다. SOP의 엄격함을 유지하면서도 필요한 통신을 허용하기 위해 태어난 것이 바로 CORS이다.

```서버에서 HTML 문서를 응답할 때 CSP를 적용하려면 어떤 HTTP 응답 헤더를 설정해야 하나요? 블로그에 나온 Express.js 코드 예시를 기반으로 설명해보세요.```

- HRML을 응답할 때 CSP 헤더를 넣으면 브라우저가 그 정책에 따라 외부 리소스,인라인 코드 실행을 제한한다. 

```jsx
// 기본: 동일 출처만 허용
app.use((req, res, next) => {
  res.setHeader('Content-Security-Policy', "default-src 'self'");
  next();
});

```

```jsx
// 위반만 보고(차단 X) + 서버로 리포트 전송
app.use((req, res, next) => {
  res.setHeader(
    'Content-Security-Policy-Report-Only',
    "default-src 'self'; report-uri /report"
  );
  next();
});

// 간단한 리포트 수신 핸들러
app.post('/report', express.text({ type: '*/*' }), (req, res) => {
  try {
    const report = JSON.parse(req.body); // 브라우저가 전송하는 CSP 위반 JSON
    console.log('CSP Report:', report);
  } catch (_) {}
  res.end();
});
```

- `default-src 'self'` 설정은 브라우저에게 어떤 보안 정책을 의미하나요? 또한 `'self'` 값은 어떤 출처를 포함하거나 제외하나요?
    - 특별히 더 좁히지 않은 모든 리소스 로딩에 대해 현재 문서와 같은 출처에서 온 것만을 허용하라는 정책이다.
    - script-src, img-src 와 같은 세부 지시자를 따로 적지 않았다면, 그 리소스들도 전부 default-src 규칙을 따른다.
    - 같은 스킴/호스트/포트의 URL들 (경로는 달라도 OK)
        - 예) 문서가 `https://app.example.com:443/page`라면
            - ✅ `https://app.example.com/…` (같은 포트 443)
            - ✅ `https://app.example.com/assets/a.js`


- 블로그에 나온 악성 스크립트(`<script>fetch(...)</script>`)를 주입했을 때 CSP가 어떻게 동작하는지 네트워크 탭과 콘솔 메시지 측면에서 설명해보세요.
    - 운영 모드에서는 네트워크 요청이 아예 발생하지 않고 콘솔에 CSP 차단 경고가 남습니다. 반대로 Report-Only에서는 요청이 실행되어 유출 위험이 현실화 되지만, 그 대신 위반 보고서가 수집됩니다. 정책을 실서비스에 투입하기 전에는 Report-Only로 관찰→정책 보정→운영 전환 순으로 적용하는 이유가 여기에 있습니다

- 기본 CSP 설정에서 인라인 스타일이 차단된다고 했습니다. 블로그 예시 중 `width:600px`이 적용되지 않는 이유를 설명하세요.
    - 정책에 style-src를 따로 쓰지 않으면 default-src ‘self’가 스타일 로딩 규칙의 기본값이 된다. 이 상태에서는 인라인 스타일이 허용되지 않는다. 따라서 width:600px 인라인 스타일의 적용 자체가 거부된다.

- 구글 애널리틱스, 카카오맵, 외부 API 등이 CSP 때문에 차단될 수 있다고 했습니다. 이러한 현상을 "건물 보안을 강화한다"는 비유와 연결해 설명해보세요.
    - 비유와 연관을 짓자면
    1. 건물 = 웹사이트
    2. 보안 게이트 = 브라우저의 CSP 엔진
    3. 출입 명부 : script-sec, img-src,connect-src 같은 CSP 지시자
    4. 사내직원 = ‘self’ (오리진)
    5. 외부 업체 = 타 오리진 리소스
    6. 1회용 출입증 = nonce/hash
    - 기본 상태가 default-src ‘self’ 이면 “사내 직원만 입장 가능” 규칙을 실행한다.

- Report-Only 모드에서는 실제 리소스 실행이 차단되지 않습니다. 그 대신 브라우저와 서버에서 각각 어떤 동작을 수행하나요?
    - 브라우저가 하는일
        - 리소스를 실제로 로드/실행 . 따라서 네트워크 탭에는 위반 리소스 요청이 찍힌다.
        - DevTools 콘솔에 Report-only 위반 메세지를 남긴다.
        - 위반 리포트 POST 전송 : 정책에 report-uri or report-to/Reporting API가 설정되어 있으면 브라우저가 그 앤드포인트로 JSON 리포트를 전송한다.
    - 서버가 하는 일
        - 리포트 수신 앤드포인트에서 JSON을 수집,로깅,분석한다. 이 데이터를 보고 어떤 출처를 script-src/img-src/connect-src등으로 열지 조정한 뒤 최종적으로는 차단모드로 전환한다.

- CSP만으로는 CSRF를 막을 수 없다고 했습니다. 블로그에 정리된 다른 보안 조치들(SameSite 쿠키, X-Frame-Options 등) 중 2가지를 설명하세요.
    1. SameSite 쿠키  - CSRF 전파 경로 자체를 차단.
        - 쿠키에 SameSite 속성을 붙여 타 사이트에서 온 요청에 쿠키가 자동 첨부되지 않게 만드는 설정이다. CSRF가 피해자가 로그인된 상태의 쿠키의 공격자 사이트에서 발생시킨 요청에 함께 실리는 점을 악용하므로 , SameSite로 교차 사이트 전송을 통제하여 전파 경로를 크게 줄일 수 있다.
    2. X-Frame-Options - 클릭재킹 차단
        - 내 페이지가 다른 사이트의 <iframe> 안에 끼워 넣어지는 것을 금지해, 투명한 오버레이로 버튼을 속여 누르게 하는 클릭 재킹을 막는다.


<h3> 블로그를 읽고 동일 출처 정책 정리하기 </h3>

- 출처(Origin)는 어떤 세 요소의 조합으로 결정되나요?
    
    스킴(프로토콜) + 호스트(도메인) + 포트의 조합이다. 이 셋이 모두 같을 때만 같은 origin으로 간주한다.
    
    - 같은 오리진: `https://app.example.com:443/a` ↔ `https://app.example.com:443/b`
    - 다른 오리진:
        - 스킴 다름: `http://example.com` ≠ `https://example.com`
        - 호스트 다름(서브도메인 포함): `https://app.example.com` ≠ `https://cdn.example.com`
        - 포트 다름: `http://example.com:80` ≠ `http://example.com:8080`

- 출처의 요소가 다른 경우(예: 프로토콜만, 포트만 다른 경우)에 같은 출처인지 아닌지를 예시 3개(같은 출처 1개, 다른 출처 2개)로 설명하세요.
    
    출처(Origin)는 **프로토콜 + 호스트 + 포트**가 모두 같아야 동일해요.
    
    1. 같은 출처 (경로/쿼리는 무관)
    - `https://app.example.com/page`
    - `https://app.example.com/other?x=1`
        
        → 프로토콜 `https`, 호스트 `app.example.com`, 포트(생략 시 443) 모두 동일 → **같은 출처**.
        
    1. 프로토콜만 다른 경우
    - `http://app.example.com/`
    - `https://app.example.com/`
        
        → 포트/호스트 같아도 `http` ≠ `https` → **다른 출처**.
        
    1. 포트만 다른 경우
    - `http://example.com:80/`
    - `http://example.com:8080/`
        
        → 프로토콜/호스트 같아도 `80` ≠ `8080` → **다른 출처**.

- 블로그에 나온 `fetch` 기반 악성 스크립트를 다른 출처로 실행했을 때 브라우저에서 어떤 일이 발생하나요? 네트워크 전송 여부, 응답 사용 가능성, 브라우저 콘솔 메시지 측면에서 서술하세요.
    
    CSP가 막으면 : 네트워크에 전송없은 + 콘솔에 CSP 위반
    
    CSP가 허용되지만 CORS 미허용일때 : 네트워크 전송이 있음 + 응답은 JS에서 사용이 불가 + 콘솔에 CORS 에러

- SOP가 어떻게 Session Hijacking(세션 하이재킹) 시도를 방지하는지 구체적으로 설명하세요. SOP가 차단하는 것과 허용되는 것(예: 네트워크 요청은 나가지만 응답 데이터에 접근 불가)을 포함하세요.
    - 교차-출처 응답 읽기 금지 : fetch/XMLHttpRequset로 다른 오리진의 응답을 프로그램적으로 읽지 못한다. 그래서 응답에 담긴 세션 의존 데이터를 탈취할 수 없다.
    - 교차-출처 DOM 접근 금지 : 다른 오리진으로 열림 창/프레임의 DOM, 쿠키에 접근할 수 없다. 목적은 “악성 사이트가 사용자데이터를 무단으로 접근, 유출하는 것을 막는데 있다.”
    - SOP가 허용하는 것
        - 네트워크 전송 자체는 가능 : 다른 출처로의 요청을 실제로 나갈 수 있다. 따라서 CSRF처럼 요청만 악용하는 시도가 가능하여 응답은 못 일겅도 부작용이 날 수 있다.

- 블로그에서 명시한 대로 SOP가 반드시 동일 출처에서만 접근하도록 하는 주요 브라우저 API/리소스 3가지를 쓰고, 각각에 대해 간단한 설명(왜 제한되는지)을 덧붙이세요.
    1. fetch() API
        - 교차 출처로 요청은 보낼 수 있어도 응답 본문을 스크립트가 읽는건 SOP로 금지 된다. 세션 , 개인정보 등 민감한 응답 데이터 유출을 막기 위한 기본 장치이다.
    2. XMLHttpRequest 
        - fetch와 동일한 논리로 교차 출처 응답 읽기 제한을 받는다. 과거부터 쓰여온 AJAX 통신 수단으라 응답 접근을 차단하지 않으면 세션 하이재킹, 데이터 스크래핑에 취약해진다.
    3. ‘’’@font-face’’’웹 폰트
        - 폰트 파일은 콘텐츠처럼 페이지 전반에 적용되므로, 임의 출처에서 폰트를 허용하면 추적, 라이선스, 보안 이슈가 생길 수 있어 기본적으로 동일 출처 제약을 받는다.

- SOP와 CSP의 차이를 블로그 내용에 따라 요점 4개(각 항목 1문장)로 정리하세요. (예: 누가 적용하는가, 제어 주체, 설정 가능 여부 등)
    1. 누가 적용하나 : SOP는 브라우저가 기본 보안 규칙으로 자동 적용하고, CSP는 서버가 헤더로 정책을 설정하면 브라우저가 그 정책을 실행한다.
    2. 제어 주체/ 설정 가능성 : SOP는 원칙적으로 앱이 임의 변경 불가, 반면 CSP는 개발자가 페이지별로 디렉티브를 세밀하게 구성할 수 있다.
    3. 보호 초점 : SOP는 교차 출처 응답 , DOM 접근 차단에 초점을 두고 , CSP는 스크립트, 스타일 ,연결  등 리소스 로딩/실행 출처를 제한해 XSS등을 억제한다.
    4. 네트워크 관점 : SOP는 교차 출처 요청은 나가도 응답 읽기는 불가인 반면 , CSP는 정책에 맞지 않으면 요청 자체를 막거나 인라인 실행을 차단한다.

- 브라우저에서 SOP 관련 차단 오류를 발견했을 때(예: 콘솔에 “동일 출처 정책으로 인해 ... 차단했습니다” 메시지) 문제 원인 파악을 위한 체크리스트(최소 3항목)를 작성하고, 임시·영구 대응 방안(각 1~2줄)도 제시하세요.
    1. 출처 비교 (스킴, 호스트,포트)
        - 요청을 보내는 페이지와 대상 URL의 스킴, 호스트, 포트가 하나라도 다른지 확인한다.
    2. 무엇이 막혔는가 (트리거 식별)
        - fetch/XMLHttpRequset, <img>/<script>/<link>, 웹폰트,iframe/DOM 접근 등이면 어떤 API/리소스에서 SOP가 발동했는지 콘솔,네트워크 탭으로 특정
    3. CORS 응답 헤더 점검
        - 대상 서버의 응답에 Access-Control-Allow-Origin , Access-Control-Allow-Credentials 등이 Vary: Origin 이 적절히 있는지 확인한다.
    - 임시 대응
        - 프록시 경유 : 백엔드에 동일 오리진 프록시를 두고 외부 요청을 서버에서 대행해 브라우저는 같은 출처로 응답하게 한다.
        - 개발 환경 완화 : 로컬에서만 대상 서버에 임시 Access-Control-Allow-Origin : * 과 필요한 CORS 헤더를 열어 동작을 확인.
    - 영구 대응
        
        정식 CORS를 구성 : 대상 서버에서 필요한 오리진만 화이트리스트로 열고 (AC-Allow-Origin:https://app.example.com), 크리덴셜이 필요하면 (AC-Allow_Credentials:true + 클라이언트 credentials : ‘include’로 맞춘다.

- 브라우저에서 `http://localhost:8080` 애플리케이션이 `http://localhost:8081/resource.json`을 요청했을 때, 네트워크 요청과 응답은 어떻게 처리되며, 브라우저가 응답 본문을 사용하지 못하는 이유는 무엇인가요?
    - `http://localhost:8080` →`http://localhost:8081/resource.json` 는 포트가 달라서 다른 출처 이므로 요청,응답의 전송은 이뤄지지만 브라우저가 응답 본문을 JS에서 쓰도록 허용하려면 CORS 승인 이 필요.

- 서버가 다른 출처(`http://localhost:8080`)에서 자원을 사용할 수 있게 하려면 어떤 응답 헤더를 어떻게 설정해야 하나요? 글의 예시 코드를 참고해 헤더 이름과 값까지 구체적으로 쓰세요.
    - 최소로는
        
        ```jsx
        res.setHeader('Access-Control-Allow-Origin','https://localhost:8080');
        ```
        
    - 커스텀 헤더 / 메서드일때 각각
        
        ```jsx
        Access-Control-AllowHeaders , Access-Control-Allows-Methods
        ```
        를 응답헤더에 함께 설정해야한다.


- 단순 요청으로 분류되기 위해서는 어떤 두 가지 조건을 만족해야 하나요? 또한 `GET /resource.json` 요청이 단순 요청에 해당하는 이유를 설명하세요.
    1. 허용된 HTTP 메서드를 쓴다. : GET,POST,HEAD
    2. 안전한 요청 헤더만 보낸다 : 예를 들어 Accept, Accept-Language, Content-Language, Content-Type,Range 등
    - GET/resource.json 요청이 단순 요청인 이유는, 메서드가 허용 목록의 GET이고 브라우저가 보내는 헤더가 안전한 헤더들만 포함되어 프리플라이트 없이 처리되기 때문.

- 브라우저에서 `X-Goguma`라는 커스텀 헤더를 추가했을 때 왜 차단이 발생하나요? 이 문제를 해결하기 위해 서버에서 추가해야 하는 응답 헤더와 값은 무엇인가요?
    - X-Goguma는 CORS의 ‘안전한 요청 헤더’ 목록에 없는 커스텀 헤더라서, 서버가 허용을 명시하지 않으면 SOP+CORS 규칙으로 본문 접근을 차단합니다.
    - 해결방법
        
        ```jsx
        Access-Control-Allow-Origin: http://localhost:8080
        Access-Control-Allow-Headers: X-Goguma
        
        ```
        
- `PUT` 요청을 보낼 때 브라우저는 왜 먼저 `OPTIONS` 요청을 보내나요? 이때 브라우저가 보내는 헤더와 서버가 응답해야 하는 헤더를 각각 쓰고, 사전 요청과 실제 요청이 어떻게 이어지는지 간단히 서술하세요.
    - 왜 OPTIONS를 먼저 보내나?
        - PUT은 단순 요청이 아닌 메서드라서 , 브라우저가 “이 교차 출처에 PUT을 써도 되는지”를 미리 확인하기 위해 사전 요청을 보낸다.
    - 브라우저가 보내는 헤더
        - 메서드 : OPTIONS
        - URL : 실제 호출할 동일 경로
        - 요청 헤더 : Access-Control-Request-Method:PUT
    - 서버가 사전 요청에 응답해야 하는 것
        - 반드시 : Access-Control-Allow-Origin: http://localhost:8080
        - 메서드 허용 : Access-Control-Allow-Methods:PUT
    - 사전 요청 → 실제 요청의 진행 순서
        1. 사전 요청 전송 : 서버가 Access-Control-Allow-Methods:PUT을 포함해 허용 응답을 보냄
        2. 브라우저가 허용을 확인하면 실제 PUT 요청을 전송하고, 응답 본문을 스크립트에서 사용 가능 상태로 넘겨준다.

```RBAC vs ABAC```

- RBAC : 역할 기반 접근 제어
    - 사용자의 역할을 기준으로 권한을 할당하는 방식
    - 작동방식
        1. 권한을 역할에 할당
        2. 사용자에게 역할 부여
    - 장점
        1. 관리효율성 : 수백 명의 사용자에게 일일이 권한을 부여할 필요 없이 역할만 할당하면 돼서 관리가 매우 편리하고 확장성이 좋다
        2. 단순함 : 구조가 명확하여 대부분의 조직 환겨에 적응하기 좋다.
        3. 정적 모델 : 역할이 한번 정의되면 잘 바뀌지 않는 비교적 공적인 방식이다.

- ABAC : 속성 기반 접근 제어
    - 속성과 조건을 기반으로 권한을 동적으로 경정하는 방식으로 RBAC보다 훨씬 세밀하고 유연한 통제가 필요할 때 사용한다.
    - 작동방식 
        1. 정책을 정의한다. 이 정책들은 속성들을 조합한 만약/그러면 형태의 규칙이다.
        2. 정책 예시 : "만약 사용자 속성이고 그리고 리소스 속성이면 그리고 환경속성일때만, 그러면 작업속성을 허용한다."

    - 장점과 특징
        1. 세분화된 제어 : '재무팀의 김철수 사원이 평일 오전 9시에서 오후 6시 사이에만 극비 파일을 읽을 수 있다'와 같은 정교한 제어가 가능
        2. 동적 모델 : 상황(시간,위치)가 바뀌면 실시간으로 접근 권환도 바뀔 수 있다.
        3. 유연성 : 새로운 리소스나 사용자 역할이 추가되어도 정책의 속성만 잘 정의하면 기존 정책을 그대로 활용할 수 있다.

- **RBAC**의 한계에 대해 설명해주세요.
    - 예외 케이스가 늘어날 수 록 표현력이 급격히 떨어진다. 초기에는 역할 만으로 충분 했지만 서비스가 커지면서 역할만으로 설명이 안되는 권한이 많아짐.
    - 역할 기준 하드코딩이 유지보수 지옥을 부른다.
    - 조직 , 리소스 단위 맥락을 담기 어렵다.
    - 권한 로직이 화면/기능마다 흩어진다.
    - 결과적으로 역할 폭증/조건 폭증으로 설계가 꼬인다.

- **ABAC**으로의 전환, 어떤 '기준'이 적절할까요?
    - 역할만으로 설명이 안되는 권한이 늘어날 때에, ex) 팀장 중에서 ‘일부’ 만 삭제 기능같은 케이스가 추가될 때
    - 조직, 맥락 의존 권한 : 사용자별로 여러 조직에 속하고 조직별 권한이 달라 리소스 맥락을 조건에 포함해야 할 때
    - 정책 변경에 민감한 제품 : PM 요청 등으로 권한 정책이 자주 바뀌어 테이블만 수정해 반영하고 싶을 때

- 어떤 서비스 영역에 **RBAC**을 남겨두고, **ABAC**을 도입하시겠어요?
    - RBAC를 남겨둘 영역 ( 전역 권한 )
        - ADMIN이 모든 챌린지에 대해 view/create/update/delete 가능 , 같은 코스 권한은 역할 테이블로 유지한다.
    - ABAC를 도입할 영역(조직,리소스 ,예외 조건)
        - 한 사용자가 여러 조직에 속하고 조직별 역할/베수 권한이 달라지는 컨텍스트 의존 권한은 속성 기반으로 푼다.

